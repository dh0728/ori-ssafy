# MSA 설계해보기
- 실제 서비스 운영을 고려해서 도메인을 설계
- MSA에서 중요한 것은 도메인 간 **결합도를 낮추고 응집도를 높이는 것**

**결합도**
- 한 서비스가 다른 서비스에 얼마나 강하게 연결되어 있는지 
- 결합도가 높으면 서비스가 변경될 때 다른 서비스도 영향을 받기 때문에 **유지보수가 어렵고 장애 전파 위험이 커진다.**

결합도를 낮추는 법

1. 데이터베이스 분리
    - 각 서비스는 자신의 데이터베이스만 사용하고, 직접 다른 서비스의 DB에 접근하지 않음.
    - 필요하면 API 호출 또는 이벤트 기반 메시징(Kafka, RabbitMQ 등) 으로 데이터를 주고받음.
2. API 호출을 최소화
    - 한 서비스가 다른 서비스의 API를 자주 호출하면 결합도가 높아짐.
    - 가능하면 비동기 메시징 방식(Kafka, RabbitMQ) 사용하여 이벤트 기반으로 통신.
    - 필요한 경우 캐싱(Redis 등) 을 사용하여 API 호출 빈도를 줄임.
3. 공통 모듈 분리
    - 여러 서비스에서 공통으로 쓰이는 기능(예: 인증, 결제)을 별도의 서비스로 독립시켜 재사용.
    - 예: 인증(Authentication) 서비스, 결제(Payment) 서비스 등.
4. API Gateway 활용
    - API Gateway를 통해 서비스 간 직접적인 API 호출을 줄이고, 단일 진입점으로 관리.
    - 이를 통해 서비스 간 결합도를 낮출 수 있음.

**응집도**
- 서비스 내부의 기능들이 얼마나 **밀접하게 관련되어 있는지**를 나타내는 개념
- 응집도가 높으면 하나의 서비스 안에 포함된 기능들이 서로 강하게 연관되어 있어 내부적으로 독립적으로 동작할 수 있음.

응집도를 높이는 방법

1. 도메인 기준으로 서비스 분리
    - 유사한 기능을 하는 것들끼리 묶어서 하나의 독립된 서비스로 분리.
    - 예: 유저 서비스, 결제 서비스, 펀딩 서비스 등.

2. 하나의 서비스 내에서 관련된 기능만 유지
    - 예를 들어 펀딩 서비스는 펀딩 상품 조회, 펀딩 참여, 펀딩 진행 상태 관리까지만 담당해야 함.
    - 결제 서비스에서 결제를 처리하고 결제 상태를 관리해야 함.

3. 서비스 간 기능 중복 방지
    - 하나의 서비스에서 처리해야 할 기능을 다른 서비스에서 중복 구현하지 않음.
    - 예를 들어 결제 로직이 펀딩 서비스에도 있고 즉시구매 서비스에도 있으면 비효율적 → 이를 결제 서비스로 따로 분리.




1. Auth 서비스 (인증/인가)
    - 유저 및 판매자 로그인/회원가입, JWT 토큰 관리, OAuth 연동 등을 담당
    - 모든 서비스의 인증 관문 역할 (API Gateway와 연계)

2. 유저 서비스
    - 유저 기본 정보 관리 (이름, 이메일, 관심 카테고리 등)
    - 마이페이지 기능 (구매 내역, 쿠폰, 포인트 등)
    - 후기도 이 서비스에서 관리 가능

3. 판매자 서비스
    - 판매자 정보 관리 (기업명, 사업자번호, 정산 정보 등)
    - 펀딩 진행 내역 및 상품 등록
    - 펀딩 서비스

4. 펀딩 상품 등록 및 관리
    - 펀딩 진행 상태 (진행 중, 마감, 목표 달성 여부)
    - 펀딩 결제 로직

5. 즉시구매 서비스
    - 즉시 구매 상품 리스트 관리
    - 장바구니 기능 포함 가능

6. 결제 서비스
    - 펀딩 및 즉시구매 결제 로직 분리
    - 결제 상태 조회, 결제 승인, 결제 취소/환불 처리

7. 채팅 서비스
    - 펀딩 상품별 오픈채팅 관리 (법적으로 6개월 이상 저장 필요)
    - WebSocket 또는 메시지 브로커(Kafka, RabbitMQ) 사용 고려

8. 쿠폰 서비스
    - 관리자(Admin)에서 생성한 쿠폰 발급 및 관리
    - 특정 유저에게 쿠폰 지급 가능

## 설계시 고려 사항
1. 서비스를 어떻게 쪼개서 구현할까?
    - 서비스에 접근할때마다 인증/인가를 해야하는 경우가 대부분이라 auth를 따로 분리하는게 맞는건가?
2. 데이터 베이스 분리를 어떻게 할까?
    - 서비스 마다 독립된 DB 사용
    - 하나의 DB에 서비스 별로 별도의 스키마를 사용
3. 서비스 마다 독립된 DB를 사용했을 때 다른 서비스에서의 DB 접근은 어떤식으로 구현해야 하는 것인가?
4. API Gateway 적용을 하는 것은 어떤가?
5. 서버간의 통신 방식을 어떻게 할 것인가?


## 고려 사항에 대한 찾은 내용

### 1. 서비스를 어떻게 쪼개서 구현할까? - 서비스에 접근할때마다 인증/인가를 해야하는 경우가 대부분이라 auth를 따로 분리하는게 맞는건가?
- 인증(Auth) 서비스를 따로 분리하고, 다른 서비스들은 인증 서비스에서 발급한 토큰을 검증하는 방식이 일반적

**JWT 기반 인증**
- 라이브러리 : Spring Security, Spring Authorization Server
- Auth 서비스에서 JWT 발급 후, 각 서비스는 JWT 검증
장점
- 서비스 간 인증 요청 최소화
- 확장성 좋음
단점
- 토큰 탈취 시 보안 문제

**세선 기반 인증**
- 라이브러리 : Spring Session, Redis	
- Auth 서비스에서 세션 생성 후 Redis 저장	
장점
- 서버 측에서 관리 가능
- 세션 만료 시 자동 로그아웃	
단점
- API Gateway 없이 쓰기 어려움

**SSO (Single Sign On)**
- 라이브러리 : Keycloak, Okta	
- OAuth 기반 중앙 인증	
장점
- 여러 서비스에서 인증 관리 가능
단점
- 설정 복잡

### 2. 데이터베이스 분리 (독립 DB vs. 하나의 DB + 스키마 분리)

**서비스별 독립 DB (PostgreSQL, MySQL)**
장점
- 서비스 간 결합도 낮음
- 장애 전파 최소화	
단점
- 운영 부담 증가
- 트랜잭션 관리 어려움	
추천 상황
대규모 확장 가능성이 있는 경우

**하나의 DB + 스키마 분리**	
장점
- 관리 용이
- 리소스 절약	
단점
- 서비스 간 결합도 높아짐
- 특정 서비스가 DB 부하를 줄 경우 전체 영향	
추천 상황
EC2 서버 하나만 운영하는 현재 상황

### 3. 서비스마다 독립된 DB를 사용했을 때, 다른 서비스에서의 DB 접근 방법
- 독립 DB를 사용하면, 다른 서비스의 데이터를 직접 읽을 수 없으므로 API 통신 또는 메시지 큐 방식으로 데이터를 주고받아야 함.

#### 선택 옵션
**REST API 요청**	
- 라이브러리 : RestTemplate, WebClient	
장점
- ✅ 구현 간단
- ✅ 실시간 데이터 조회	
단점
- ❌ 네트워크 부하 발생
- ❌ API 변경 시 영향	
추천 상황 : 단순 데이터 조회

**gRPC (고성능 RPC)**	
- 라이브러리 : Spring gRPC
장점	
- ✅ API 호출보다 빠름
- ✅ 데이터 크기 작음	
단점
- ❌ 유지보수 어려움    
- ❌ 초반 설정 복잡	
추천 상황 : 고속 데이터 요청 필요 시

**이벤트 기반 메시징**	
라이브러리: Kafka, RabbitMQ	
장점
- ✅ 비동기 처리 가능
- ✅ 트랜잭션 최소화	❌ 실시간 조회 불가능
단점
- ❌ 운영 비용 증가	
추천상황: 결제 완료 후 상태 변경 등 이벤트성 데이터

**읽기 요청은 REST API(WebClient), 비동기 이벤트는 Kafka를 사용하는 하이브리드 방식도 가능**

### 4. API Gateway 적용 여부
- API Gateway를 적용하면 클라이언트가 여러 서비스의 API를 호출하는 것을 단순화 가능.

#### 선택 옵션
**REST API (HTTP)**	
- WebClient, Feign Client	
장점
- ✅ 구현 간단
- ✅ 익숙한 방식	
단점
- ❌ 속도가 느림	
추천상황 : 일반적인 데이터 조회

**gRPC (Binary 기반)**	
- 라이브러리 : Spring gRPC	
장점
- ✅ 속도 빠름
- ✅ 경량화된 데이터 전송	
단점
- ❌ 설정 복잡	고성능 데이터 전송 필요

**이벤트 메시징 (비동기)**	
라이브러리 : Kafka, RabbitMQ	
장점
- ✅ 비동기 처리 가능
- ✅ 서비스 간 결합도 낮음	
단점
- ❌ 실시간 조회 불가능	
추천상황 : 결제 완료 후 펀딩 서비스에 알림 등 이벤트성 데이터

Spring Cloud Gateway 사용 추천
- http://gateway/api/user → http://user-service:8081/api
- JWT 인증 및 로깅 기능 추가 가능


### 5. 서버 간의 통신 방식
- 서비스 간 통신 방식으로는 REST API, gRPC, 메시지 큐 3가지가 대표적

#### 옵션 비교
**REST API (HTTP)**	
- 라이브러리 : WebClient, Feign Client	
장점
- ✅ 구현 간단
- ✅ 익숙한 방식	
단점
- ❌ 속도가 느림	
추천상황 : 일반적인 데이터 조회

**gRPC (Binary 기반)**	
- Spring gRPC	
장점
- ✅ 속도 빠름
- ✅ 경량화된 데이터 전송	
단점
- ❌ 설정 복잡	
추천상황 : 고성능 데이터 전송 필요

**이벤트 메시징 (비동기)**
- 라이브러리 : Kafka, RabbitMQ	
장점
- ✅ 비동기 처리 가능
- ✅ 서비스 간 결합도 낮음	
단점
- ❌ 실시간 조회 불가능	
추천상황 : 결제 완료 후 펀딩 서비스에 알림 등 이벤트성 데이터

결론: 주요 데이터는 REST API(WebClient), 비동기 이벤트는 Kafka 사용
- 결제 완료 시 Kafka 이벤트 발행
- 일반적인 서비스 간 데이터 조회는 REST API 사용


NoSQL이 좋을 서비스도 있고 RDB가 좋은 서비스도 있으니까 서비스 별로 DB 선택해서 스키마를 분리하는 하이브리드 방식도 좋아보이는데 어떻게 생각하니?